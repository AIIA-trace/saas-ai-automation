const WebSocket = require('ws');
const logger = require('../utils/logger');
const OpenAI = require('openai');
const { PrismaClient } = require('@prisma/client');
const AzureTTSStreaming = require('../services/azureTTSStreaming');
const RealtimeTranscription = require('../services/realtimeTranscription');

const prisma = new PrismaClient();
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const azureTTS = new AzureTTSStreaming();
const transcriptionService = new RealtimeTranscription();

class TwilioStreamHandler {
  constructor() {
    this.activeStreams = new Map(); // CallSid -> StreamData
    this.audioBuffers = new Map(); // CallSid -> Buffer chunks
    this.conversationState = new Map(); // CallSid -> conversation history
  }

  /**
   * Configurar nueva conexi√≥n WebSocket
   */
  handleConnection(ws, req) {
    const streamId = this.generateStreamId();
    ws.streamId = streamId;
    
    logger.info(`üîå Nueva conexi√≥n WebSocket: ${streamId}`);
    logger.info(`üîç URL completa: ${req.url}`);
    logger.info(`üîç Headers: ${JSON.stringify(req.headers, null, 2)}`);

    // Los par√°metros de Twilio Stream se env√≠an en los eventos, no en la URL
    // Inicializar como null hasta que lleguen en los eventos
    ws.callSid = null;
    ws.clientId = null;
    ws.companyName = null;
    ws.language = null;
    
    ws.streamId = streamId;
    ws.isAlive = true;

    // Heartbeat para mantener conexi√≥n
    ws.on('pong', () => {
      ws.isAlive = true;
    });

    // Manejar mensajes de Twilio
    ws.on('message', async (message) => {
      try {
        const data = JSON.parse(message);
        await this.handleTwilioMessage(ws, data);
      } catch (error) {
        logger.error(`‚ùå Error procesando mensaje WebSocket: ${error.message}`);
      }
    });

    // Limpiar al cerrar conexi√≥n
    ws.on('close', () => {
      this.cleanupStream(ws.streamId);
      logger.info(`üîå Conexi√≥n WebSocket cerrada: ${streamId}`);
    });

    ws.on('error', (error) => {
      logger.error(`‚ùå Error WebSocket ${streamId}: ${error.message}`);
      this.cleanupStream(ws.streamId);
    });
  }

  /**
   * Manejar eventos de Twilio Stream
   */
  async handleTwilioMessage(ws, data) {
    const { event } = data;
    
    logger.debug(`üì® Evento Twilio recibido: ${event}`);
    logger.debug(`üì® Datos completos del evento: ${JSON.stringify(data, null, 2)}`);
    
    switch (event) {
      case 'connected':
        await this.handleStreamConnected(ws, data);
        break;
      case 'start':
        await this.handleStreamStart(ws, data);
        break;
      case 'media':
        await this.handleMediaChunk(ws, data);
        break;
      case 'stop':
        await this.handleStreamStop(ws, data);
        break;
      default:
        logger.debug(`üîç Evento no manejado: ${event}`);
    }
  }

  /**
   * Stream conectado - inicializar
   */
  async handleStreamConnected(ws, data) {
    const { streamSid } = data;
    logger.info(`‚úÖ Stream conectado: ${streamSid}`);
    
    // Extraer par√°metros del evento connected si est√°n disponibles
    if (data.parameters) {
      logger.info(`üîç Par√°metros en evento connected: ${JSON.stringify(data.parameters)}`);
      
      // Extraer par√°metros del stream
      const parameters = data.parameters || {};
      ws.clientId = parameters.clientId;
      ws.callSid = parameters.callSid;
    }
    
    // El evento connected no siempre tiene todos los par√°metros
    // Esperar al evento start para obtener todos los par√°metros
    logger.info(`üé§ Stream conectado, esperando evento start para par√°metros completos`);
  }

  /**
   * Stream iniciado - configurar cliente
   */
  async handleStreamStart(ws, data) {
    const { streamSid } = data;
    
    // Debug: log completo del evento start para verificar estructura
    logger.info(`üîç Evento start completo:`, JSON.stringify(data, null, 2));
    logger.info(`üîç data.start:`, JSON.stringify(data.start, null, 2));
    logger.info(`üîç Todas las keys en data:`, Object.keys(data));
    
    // Intentar m√∫ltiples formas de extraer los datos
    const startData = data.start || data;
    const twilioNumber = startData.to || data.to;
    const callerNumber = startData.from || data.from;
    const customParameters = startData.customParameters || data.customParameters;
    
    // Extraer clientId de los par√°metros personalizados
    let clientId = null;
    if (customParameters) {
      // Los par√°metros pueden venir como objeto o array
      if (Array.isArray(customParameters)) {
        const clientIdParam = customParameters.find(p => p.name === 'clientId');
        clientId = clientIdParam ? clientIdParam.value : null;
      } else if (customParameters.clientId) {
        clientId = customParameters.clientId;
      }
    }
    
    // Obtener CallSid desde par√°metros personalizados o desde data
    const callSid = customParameters?.callSid || data.callSid || streamSid;

    logger.info(`üé§ Stream iniciado: ${streamSid} para llamada ${callSid}`);
    logger.info(`üìû ${callerNumber || 'undefined'} ‚Üí ${twilioNumber || 'undefined'}`);
    logger.info(`üÜî ClientId extra√≠do: ${clientId}`);

    try {
      let client = null;
      
      // Si tenemos clientId, usarlo directamente
      if (clientId) {
        client = await prisma.client.findUnique({
          where: { id: parseInt(clientId) },
          include: {
            twilioNumbers: true
          }
        });
        
        if (client) {
          logger.info(`‚úÖ Cliente encontrado por ID: ${client.companyName} (ID: ${client.id})`);
          logger.info(`üéµ WelcomeMessage: "${client.welcomeMessage || 'NO CONFIGURADO'}"`);
          logger.info(`üè¢ CompanyInfo: "${client.companyInfo || 'NO CONFIGURADO'}"`);
        }
      }
      
      // Si no encontramos cliente por ID, buscar por n√∫mero de Twilio
      if (!client && twilioNumber) {
        const twilioNumberRecord = await prisma.twilioNumber.findFirst({
          where: { 
            phoneNumber: twilioNumber,
            status: 'active'
          },
          include: { 
            client: {
              include: {
                twilioNumbers: true
              }
            }
          }
        });

        if (twilioNumberRecord && twilioNumberRecord.client) {
          client = twilioNumberRecord.client;
          logger.info(`‚úÖ Cliente encontrado por n√∫mero: ${client.companyName} (ID: ${client.id})`);
          logger.info(`üéµ WelcomeMessage: "${client.welcomeMessage || 'NO CONFIGURADO'}"`);
          logger.info(`üè¢ CompanyInfo: "${client.companyInfo || 'NO CONFIGURADO'}"`);
        }
      }

      if (!client) {
        logger.error(`‚ùå Cliente no encontrado para n√∫mero: ${twilioNumber} o ID: ${clientId}`);
        return;
      }

      // Debug: verificar datos del cliente antes de almacenar
      logger.info(`üîç Datos del cliente antes de almacenar en stream:`, JSON.stringify({
        id: client.id,
        companyName: client.companyName,
        welcomeMessage: client.welcomeMessage,
        companyInfo: client.companyInfo,
        language: client.language
      }, null, 2));

      // Inicializar estado del stream USANDO STREAMSID COMO CLAVE
      this.activeStreams.set(streamSid, {
        streamSid,
        callSid,
        clientId: client.id,
        clientData: client,
        callerNumber,
        twilioNumber,
        ws,
        startTime: Date.now(),
        lastActivity: Date.now()
      });

      this.audioBuffers.set(streamSid, []);
      this.conversationState.set(streamSid, []);

      logger.info(`‚úÖ Cliente configurado: ${client.companyName} (ID: ${client.id})`);

      // Verificar que los datos se almacenaron correctamente
      const storedStreamData = this.activeStreams.get(streamSid);
      logger.info(`üîç Datos almacenados en activeStreams:`, JSON.stringify({
        clientId: storedStreamData.clientId,
        companyName: storedStreamData.clientData.companyName,
        welcomeMessage: storedStreamData.clientData.welcomeMessage
      }, null, 2));

      // Ahora que tenemos el CallSid y el cliente configurado, enviar saludo inicial
      await this.sendInitialGreeting(ws, { streamSid, callSid });

    } catch (error) {
      logger.error(`‚ùå Error configurando stream: ${error.message}`);
    }
  }

  /**
   * Enviar saludo inicial con Azure TTS
   */
  async sendInitialGreeting(ws, data) {
    try {
      const { streamSid, callSid } = data;
      
      // Obtener datos del stream usando streamSid como clave
      const streamData = this.activeStreams.get(streamSid);
      if (!streamData) {
        logger.warn(`‚ö†Ô∏è Stream no encontrado para StreamSid: ${streamSid}`);
        return;
      }
      
      // Debug: mostrar todos los datos del cliente
      logger.info(`üîç Datos completos del cliente:`, JSON.stringify({
        id: streamData.clientData.id,
        companyName: streamData.clientData.companyName,
        welcomeMessage: streamData.clientData.welcomeMessage,
        companyInfo: streamData.clientData.companyInfo,
        language: streamData.clientData.language,
        botPersonality: streamData.clientData.botPersonality
      }, null, 2));
      
      // Usar SOLO el mensaje de bienvenida personalizado del cliente
      const greetingText = streamData.clientData.welcomeMessage;
      
      if (!greetingText || greetingText.trim() === '') {
        logger.error(`‚ùå Cliente ${streamData.clientData.companyName} no tiene welcomeMessage configurado o est√° vac√≠o`);
        logger.error(`‚ùå WelcomeMessage value: "${greetingText}"`);
        
        // Usar mensaje por defecto temporal
        const defaultGreeting = `Hola, gracias por llamar a ${streamData.clientData.companyName}. En este momento nuestro sistema est√° configur√°ndose. Por favor, intente m√°s tarde.`;
        
        logger.info(`üéµ Enviando saludo por defecto para ${streamData.clientData.companyName}`);
        
        const voice = 'es-ES-DarioNeural';
        const audioBuffer = await azureTTS.synthesizeToStream(defaultGreeting, voice);
        await azureTTS.streamAudioToWebSocket(ws, audioBuffer, streamSid);
        
        return;
      }
      
      logger.info(`üéµ Enviando saludo inicial para StreamSid ${streamSid}: "${greetingText}"`);
      
      // Generar audio con Azure TTS usando voz espa√±ola
      const voice = 'es-ES-DarioNeural';
      const audioBuffer = await azureTTS.synthesizeToStream(greetingText, voice);
      await azureTTS.streamAudioToWebSocket(ws, audioBuffer, streamSid);
      
      logger.info(`‚úÖ Saludo inicial enviado correctamente para StreamSid: ${streamSid}`);
      
    } catch (error) {
      logger.error(`‚ùå Error enviando saludo: ${error.message}`);
      const fallbackText = "Sistema temporalmente no disponible. Por favor, intente m√°s tarde.";
      
      try {
        const voice = 'es-ES-DarioNeural';
        const audioBuffer = await azureTTS.synthesizeToStream(fallbackText, voice);
        await azureTTS.streamAudioToWebSocket(ws, audioBuffer, data.streamSid);
      } catch (fallbackError) {
        logger.error(`‚ùå Error enviando mensaje de fallback: ${fallbackError.message}`);
      }
    }
  }

  /**
   * Procesar chunk de audio del usuario
   */
  async handleMediaChunk(ws, data) {
    const { streamSid, media } = data;
    
    // Usar streamSid directamente como clave
    if (!this.activeStreams.has(streamSid)) {
      logger.warn(`‚ö†Ô∏è Stream no encontrado para StreamSid: ${streamSid}`);
      return;
    }

    // Decodificar audio base64
    const audioChunk = Buffer.from(media.payload, 'base64');
    
    // Acumular chunks de audio usando streamSid
    const buffer = this.audioBuffers.get(streamSid) || [];
    buffer.push(audioChunk);
    this.audioBuffers.set(streamSid, buffer);

    // Actualizar actividad
    const streamData = this.activeStreams.get(streamSid);
    streamData.lastActivity = Date.now();

    // Procesar cuando tengamos suficiente audio (ej: 1 segundo)
    const totalSize = buffer.reduce((sum, chunk) => sum + chunk.length, 0);
    if (totalSize > 8000) { // ~1 segundo de audio a 8kHz
      await this.processAudioBuffer(streamSid);
    }
  }

  /**
   * Procesar buffer de audio acumulado
   */
  async processAudioBuffer(streamSid) {
    const buffer = this.audioBuffers.get(streamSid);
    const streamData = this.activeStreams.get(streamSid);

    if (!buffer || !streamData) return;

    try {
      // Combinar chunks en un solo buffer
      const audioData = Buffer.concat(buffer);
      
      // Limpiar buffer
      this.audioBuffers.set(streamSid, []);

      // Transcribir con Whisper
      const transcription = await this.transcribeAudio(audioData);
      
      if (transcription && transcription.trim()) {
        logger.info(`üé§ Transcripci√≥n: "${transcription}"`);
        
        // Generar respuesta IA
        const aiResponse = await this.generateAIResponse(streamSid, transcription);
        
        if (aiResponse) {
          logger.info(`ü§ñ Respuesta IA: "${aiResponse}"`);
          
          // Enviar respuesta con TTS
          await this.sendTTSAudio(streamData.ws, aiResponse);
        }
      }

    } catch (error) {
      logger.error(`‚ùå Error procesando audio: ${error.message}`);
    }
  }

  /**
   * Transcribir audio con servicio de transcripci√≥n en tiempo real
   */
  async transcribeAudio(audioBuffer) {
    try {
      const result = await transcriptionService.transcribeAudioBuffer(audioBuffer, 'es');
      
      if (result.success) {
        return result.text;
      } else {
        logger.warn(`‚ö†Ô∏è Transcripci√≥n fall√≥: ${result.error}`);
        return null;
      }

    } catch (error) {
      logger.error(`‚ùå Error transcribiendo audio: ${error.message}`);
      return null;
    }
  }

  /**
   * Construir contexto completo del cliente para GPT-4
   */
  buildClientContext(clientData) {
    let context = `Eres un asistente virtual para ${clientData.companyName}.`;
    
    // A√±adir descripci√≥n de la empresa
    if (clientData.companyDescription) {
      context += `\n\nDescripci√≥n de la empresa: ${clientData.companyDescription}`;
    }
    
    // A√±adir informaci√≥n de la empresa desde JSON
    if (clientData.companyInfo) {
      const companyInfo = typeof clientData.companyInfo === 'string' 
        ? JSON.parse(clientData.companyInfo) 
        : clientData.companyInfo;
      
      if (companyInfo.services) context += `\nServicios: ${companyInfo.services}`;
      if (companyInfo.address) context += `\nDirecci√≥n: ${companyInfo.address}`;
      if (companyInfo.phone) context += `\nTel√©fono: ${companyInfo.phone}`;
      if (companyInfo.email) context += `\nEmail: ${companyInfo.email}`;
      if (companyInfo.website) context += `\nWeb: ${companyInfo.website}`;
    }
    
    // A√±adir FAQs
    if (clientData.faqs) {
      const faqs = typeof clientData.faqs === 'string' 
        ? JSON.parse(clientData.faqs) 
        : clientData.faqs;
      
      if (Array.isArray(faqs) && faqs.length > 0) {
        context += `\n\nPreguntas frecuentes:`;
        faqs.forEach((faq, index) => {
          context += `\n${index + 1}. P: ${faq.question}\n   R: ${faq.answer}`;
        });
      }
    }
    
    // A√±adir archivos de contexto
    if (clientData.contextFiles) {
      const contextFiles = typeof clientData.contextFiles === 'string' 
        ? JSON.parse(clientData.contextFiles) 
        : clientData.contextFiles;
      
      if (Array.isArray(contextFiles) && contextFiles.length > 0) {
        context += `\n\nInformaci√≥n adicional:`;
        contextFiles.forEach(file => {
          if (file.content) context += `\n- ${file.content}`;
        });
      }
    }
    
    // A√±adir horario comercial
    if (clientData.businessHoursConfig) {
      const businessHours = typeof clientData.businessHoursConfig === 'string' 
        ? JSON.parse(clientData.businessHoursConfig) 
        : clientData.businessHoursConfig;
      
      if (businessHours.schedule) {
        context += `\n\nHorario de atenci√≥n: ${businessHours.schedule}`;
      }
    }
    
    // A√±adir personalidad del bot
    if (clientData.botPersonality) {
      context += `\n\nPersonalidad: ${clientData.botPersonality}`;
    }
    
    context += `\n\nInstrucciones: Responde de forma natural, amigable y concisa. M√°ximo 2 frases por respuesta. Usa la informaci√≥n proporcionada para ayudar al cliente.`;
    
    return context;
  }

  /**
   * Generar respuesta con IA
   */
  async generateAIResponse(streamSid, userInput) {
    const streamData = this.activeStreams.get(streamSid);
    const conversation = this.conversationState.get(streamSid) || [];

    try {
      // A√±adir mensaje del usuario
      conversation.push({ role: 'user', content: userInput });

      // Construir contexto completo del cliente
      const clientContext = this.buildClientContext(streamData.clientData);
      
      // Generar respuesta con OpenAI usando contexto personalizado
      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: clientContext
          },
          ...conversation
        ],
        max_tokens: 150,
        temperature: 0.7
      });

      const aiResponse = completion.choices[0].message.content;

      // Guardar respuesta en conversaci√≥n
      conversation.push({ role: 'assistant', content: aiResponse });
      this.conversationState.set(streamSid, conversation);

      return aiResponse;

    } catch (error) {
      logger.error(`‚ùå Error generando respuesta IA: ${error.message}`);
      return null;
    }
  }

  /**
   * Enviar audio TTS al stream
   */
  async sendTTSAudio(ws, text) {
    try {
      logger.info(`üéµ Enviando TTS: "${text}"`);
      
      // Obtener streamSid y callSid del WebSocket
      const streamData = this.getStreamDataFromWs(ws);
      if (!streamData) {
        logger.error(`‚ùå No se encontr√≥ stream data para el WebSocket`);
        return;
      }
      
      const { streamSid, callSid } = streamData;
      logger.info(`üéµ Enviando TTS para CallSid ${callSid}: "${text}"`);
      
      // Generar audio con Azure TTS
      const audioBuffer = await azureTTS.synthesizeToStream(text);
      
      // Enviar por streaming
      await azureTTS.streamAudioToWebSocket(ws, audioBuffer, streamSid);
      
      logger.info(`‚úÖ TTS enviado correctamente para CallSid: ${callSid}`);

    } catch (error) {
      logger.error(`‚ùå Error enviando TTS: ${error.message}`);
      // Fallback a mensaje de texto
      await this.sendFallbackMessage(ws, text);
    }
  }

  /**
   * Obtener streamSid desde WebSocket
   */
  getStreamSidFromWs(ws) {
    for (const [streamSid, streamData] of this.activeStreams.entries()) {
      if (streamData.ws === ws) {
        return streamData.streamSid;
      }
    }
    return null;
  }

  /**
   * Obtener datos completos del stream desde WebSocket
   */
  getStreamDataFromWs(ws) {
    for (const [streamSid, streamData] of this.activeStreams.entries()) {
      if (streamData.ws === ws) {
        return streamData;
      }
    }
    return null;
  }

  /**
   * Enviar mensaje de fallback cuando TTS falla
   */
  async sendFallbackMessage(ws, text) {
    try {
      const message = {
        event: 'mark',
        streamSid: this.getStreamSidFromWs(ws),
        mark: {
          name: 'tts_fallback'
        }
      };
      
      ws.send(JSON.stringify(message));
      logger.info(`üìù Fallback message enviado: "${text}"`);
      
    } catch (error) {
      logger.error(`‚ùå Error enviando fallback: ${error.message}`);
    }
  }

  /**
   * Stream terminado
   */
  async handleStreamStop(ws, data) {
    const { streamSid } = data;
    
    logger.info(`üõë Stream terminado: ${streamSid}`);
    
    if (this.activeStreams.has(streamSid)) {
      this.cleanupStream(streamSid);
    }
  }

  /**
   * Limpiar recursos del stream
   */
  cleanupStream(streamSid) {
    if (this.activeStreams.has(streamSid)) {
      this.activeStreams.delete(streamSid);
      this.audioBuffers.delete(streamSid);
      this.conversationState.delete(streamSid);
      logger.info(`üßπ Stream limpiado: ${streamSid}`);
    }
  }

  /**
   * Generar ID √∫nico para stream
   */
  generateStreamId() {
    return `stream_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Heartbeat para mantener conexiones activas
   */
  startHeartbeat() {
    setInterval(() => {
      this.activeStreams.forEach((streamData, streamSid) => {
        if (!streamData.ws.isAlive) {
          logger.warn(`üíî Conexi√≥n WebSocket muerta: ${streamSid}`);
          streamData.ws.terminate();
          this.cleanupStream(streamSid);
          return;
        }

        streamData.ws.isAlive = false;
        streamData.ws.ping();
      });
    }, 30000); // Cada 30 segundos
  }
}

module.exports = TwilioStreamHandler;
