const sdk = require('microsoft-cognitiveservices-speech-sdk');
const fs = require('fs');
const path = require('path');
const logger = require('../utils/logger');

class AzureTTSService {
  constructor() {
    this.subscriptionKey = process.env.AZURE_SPEECH_KEY || '123456dummy_key_for_testing';
    this.region = process.env.AZURE_SPEECH_REGION || 'westeurope';
    
    logger.info(`üîç DEBUG CONSTRUCTOR Azure TTS - Key configurada: ${this.subscriptionKey ? 'S√ç' : 'NO'} (${this.subscriptionKey?.substring(0, 5)}...)`);  
    logger.info(`üîç DEBUG CONSTRUCTOR Azure TTS - Regi√≥n: ${this.region}`);
    
    // Voces espa√±olas disponibles (nombres EXACTOS de Azure Speech Studio)
    this.availableVoices = [
      {
        id: 'lola',
        name: 'en-US-LolaMultilingualNeural',
        azureName: 'en-US-LolaMultilingualNeural',
        locale: 'es-ES',
        description: 'Voz Lola multiling√ºe (funciona en espa√±ol)'
      },
      {
        id: 'dario',
        name: 'es-ES-DarioNeural', 
        azureName: 'es-ES-DarioNeural',
        locale: 'es-ES',
        description: 'Voz masculina espa√±ola oficial'
      }
    ];
    
    this.defaultVoice = 'lola'; // Voz por defecto
    
    if (!this.subscriptionKey) {
      logger.warn('‚ö†Ô∏è AZURE_SPEECH_KEY no configurada. Azure TTS no funcionar√°.');
    }
  }

  // Obtener configuraci√≥n de Azure Speech
  getSpeechConfig() {
    if (!this.subscriptionKey) {
      throw new Error('Azure Speech Key no configurada');
    }
    
    logger.info(`üîç DEBUG Azure TTS - Configurando con regi√≥n: ${this.region}`);
    logger.info(`üîç DEBUG Azure TTS - Clave configurada: ${this.subscriptionKey ? 'S√ç' : 'NO'}`);
    
    // CONFIGURACI√ìN OFICIAL SEG√öN DOCUMENTACI√ìN DE MICROSOFT
    const speechConfig = sdk.SpeechConfig.fromSubscription(this.subscriptionKey, this.region);
    
    // Configurar idioma espa√±ol
    speechConfig.speechSynthesisLanguage = "es-ES";
    
    // Configurar formato de salida para Twilio (Œº-law 8kHz mono)
    speechConfig.speechSynthesisOutputFormat = sdk.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw;
    
    logger.info(`üîç DEBUG Azure TTS - SpeechConfig creado correctamente con fromSubscription`);
    
    return speechConfig;
  }

  // Obtener voz por ID
  getVoiceById(voiceId) {
    return this.availableVoices.find(v => v.id === voiceId) || this.availableVoices[0];
  }

  // Generar audio a partir de texto
  async generateSpeech(text, voice = 'lola', outputPath = null) {
    const generateId = `GENERATE_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    const generateStartTime = Date.now();
    
    logger.info(`üîç [${generateId}] ===== GENERATESPEECH ENTRY POINT =====`);
    logger.info(`üîç [${generateId}] Par√°metros recibidos:`);
    logger.info(`üîç [${generateId}]   - text: "${text}" (tipo: ${typeof text}, length: ${text?.length || 0})`);
    logger.info(`üîç [${generateId}]   - voice: "${voice}" (tipo: ${typeof voice})`);
    logger.info(`üîç [${generateId}]   - outputPath: ${outputPath || 'null'} (tipo: ${typeof outputPath})`);
    
    // Validaciones de entrada
    if (!text || typeof text !== 'string' || text.trim().length === 0) {
      logger.error(`‚ùå [${generateId}] Texto inv√°lido: "${text}"`);
      return { success: false, error: 'Texto vac√≠o o inv√°lido' };
    }
    
    if (!voice || typeof voice !== 'string') {
      logger.warn(`‚ö†Ô∏è [${generateId}] Voz inv√°lida: "${voice}", usando 'lola'`);
      voice = 'lola';
    }
    try {
      const selectedVoice = this.getVoiceById(voice);
      
      logger.info(`üîç DEBUG Azure TTS - Generando audio con voz: ${selectedVoice.name}`);
      logger.info(`üîç DEBUG Azure TTS - Texto: "${text.substring(0, 50)}..."`);
      logger.info(`üîç DEBUG Azure TTS - Azure Voice Name: ${selectedVoice.azureName}`);
      
      const speechConfig = this.getSpeechConfig();
      speechConfig.speechSynthesisVoiceName = selectedVoice.azureName;
      
      logger.info(`üîç DEBUG Azure TTS - SpeechConfig configurado con voz: ${selectedVoice.azureName}`);
      
      // Configurar salida
      let audioConfig;
      if (outputPath) {
        // Asegurar que el directorio existe antes de crear el archivo
        const outputDir = path.dirname(outputPath);
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
          logger.info(`üîç DEBUG Azure TTS - Directorio creado: ${outputDir}`);
        }
        audioConfig = sdk.AudioConfig.fromAudioFileOutput(outputPath);
        logger.info(`üîç DEBUG Azure TTS - AudioConfig configurado para archivo: ${outputPath}`);
      } else {
        audioConfig = sdk.AudioConfig.fromDefaultSpeakerOutput();
        logger.info(`üîç DEBUG Azure TTS - AudioConfig configurado para speaker por defecto`);
      }
      
      const synthesizer = new sdk.SpeechSynthesizer(speechConfig, audioConfig);
      logger.info(`üîç DEBUG Azure TTS - SpeechSynthesizer creado, iniciando s√≠ntesis...`);
      
      return new Promise((resolve, reject) => {
        const ttsDebugId = `TTS_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
        const ttsStartTime = Date.now();
        
        logger.info(`üîç [${ttsDebugId}] ===== AZURE TTS S√çNTESIS INICIADA =====`);
        logger.info(`üîç [${ttsDebugId}] Texto: "${text}" (${text.length} chars)`);
        logger.info(`üîç [${ttsDebugId}] Voz: ${voice}`);
        logger.info(`üîç [${ttsDebugId}] OutputPath: ${outputPath || 'ninguno'}`);
        logger.info(`üîç [${ttsDebugId}] Synthesizer creado: ${!!synthesizer}`);
        
        // Timeout de 15 segundos para Azure TTS (aumentado para debug)
        const timeout = setTimeout(() => {
          const timeoutDuration = Date.now() - ttsStartTime;
          logger.error(`‚ùå [${ttsDebugId}] TIMEOUT despu√©s de ${timeoutDuration}ms (l√≠mite: 15s)`);
          logger.error(`‚ùå [${ttsDebugId}] Synthesizer state antes del timeout: ${synthesizer ? 'exists' : 'null'}`);
          synthesizer?.close();
          reject(new Error(`Azure TTS timeout despu√©s de ${timeoutDuration}ms`));
        }, 15000);

        logger.info(`üîç [${ttsDebugId}] Llamando synthesizer.speakTextAsync...`);
        
        synthesizer.speakTextAsync(
          text,
          (result) => {
            const callbackTime = Date.now();
            const callbackDuration = callbackTime - ttsStartTime;
            
            clearTimeout(timeout);
            logger.info(`üîç [${ttsDebugId}] ===== CALLBACK √âXITO despu√©s de ${callbackDuration}ms =====`);
            logger.info(`üîç [${ttsDebugId}] Result reason: ${result.reason}`);
            logger.info(`üîç [${ttsDebugId}] Result reason code: ${sdk.ResultReason.SynthesizingAudioCompleted}`);
            logger.info(`üîç [${ttsDebugId}] Reasons match: ${result.reason === sdk.ResultReason.SynthesizingAudioCompleted}`);
            
            if (result.reason === sdk.ResultReason.SynthesizingAudioCompleted) {
              logger.info(`‚úÖ [${ttsDebugId}] S√çNTESIS COMPLETADA EXITOSAMENTE`);
              
              // An√°lisis detallado del audioData
              logger.info(`üîç [${ttsDebugId}] Analizando audioData...`);
              logger.info(`üîç [${ttsDebugId}]   - audioData existe: ${!!result.audioData}`);
              logger.info(`üîç [${ttsDebugId}]   - audioData tipo: ${typeof result.audioData}`);
              
              if (result.audioData) {
                logger.info(`üîç [${ttsDebugId}]   - audioData constructor: ${result.audioData.constructor.name}`);
                logger.info(`üîç [${ttsDebugId}]   - audioData byteLength: ${result.audioData.byteLength}`);
                logger.info(`üîç [${ttsDebugId}]   - audioData length: ${result.audioData.length}`);
                
                // Verificar contenido del buffer
                if (result.audioData.byteLength > 0) {
                  const firstBytes = new Uint8Array(result.audioData.slice(0, Math.min(10, result.audioData.byteLength)));
                  const lastBytes = new Uint8Array(result.audioData.slice(-Math.min(10, result.audioData.byteLength)));
                  logger.info(`üîç [${ttsDebugId}]   - Primeros bytes: [${Array.from(firstBytes).join(', ')}]`);
                  logger.info(`üîç [${ttsDebugId}]   - √öltimos bytes: [${Array.from(lastBytes).join(', ')}]`);
                  
                  // Verificar si es WAV v√°lido
                  if (result.audioData.byteLength >= 4) {
                    const header = new Uint8Array(result.audioData.slice(0, 4));
                    const headerStr = String.fromCharCode(...header);
                    logger.info(`üîç [${ttsDebugId}]   - Header detectado: "${headerStr}"`);
                    logger.info(`üîç [${ttsDebugId}]   - Es WAV v√°lido: ${headerStr === 'RIFF'}`);
                  }
                } else {
                  logger.error(`‚ùå [${ttsDebugId}] audioData tiene 0 bytes!`);
                }
              } else {
                logger.error(`‚ùå [${ttsDebugId}] audioData es null/undefined!`);
              }
              
              // Manejo de archivo de salida
              if (outputPath) {
                logger.info(`üîç [${ttsDebugId}] Verificando archivo de salida...`);
                if (fs.existsSync(outputPath)) {
                  const stats = fs.statSync(outputPath);
                  logger.info(`‚úÖ [${ttsDebugId}] Archivo guardado: ${outputPath} (${stats.size} bytes)`);
                  
                  // Verificar que el tama√±o del archivo coincide con audioData
                  if (result.audioData && stats.size !== result.audioData.byteLength) {
                    logger.warn(`‚ö†Ô∏è [${ttsDebugId}] Tama√±o inconsistente: archivo=${stats.size}, buffer=${result.audioData.byteLength}`);
                  }
                } else {
                  logger.error(`‚ùå [${ttsDebugId}] Archivo no encontrado: ${outputPath}`);
                }
                
                logger.info(`üîç [${ttsDebugId}] Resolviendo con outputPath...`);
                resolve({
                  success: true,
                  outputPath,
                  audioBuffer: result.audioData
                });
              } else {
                logger.info(`üîç [${ttsDebugId}] Resolviendo solo con audioBuffer...`);
                resolve({
                  success: true,
                  audioBuffer: result.audioData
                });
              }
              
            } else if (result.reason === sdk.ResultReason.Canceled) {
              const cancellation = sdk.CancellationDetails.fromResult(result);
              logger.error(`‚ùå [${ttsDebugId}] S√çNTESIS CANCELADA despu√©s de ${callbackDuration}ms:`);
              logger.error(`‚ùå [${ttsDebugId}]   - Cancellation reason: ${cancellation.reason}`);
              logger.error(`‚ùå [${ttsDebugId}]   - Error code: ${cancellation.errorCode}`);
              logger.error(`‚ùå [${ttsDebugId}]   - Error details: ${cancellation.errorDetails}`);
              
              // An√°lisis detallado de la cancelaci√≥n
              if (cancellation.reason === sdk.CancellationReason.Error) {
                logger.error(`‚ùå [${ttsDebugId}] TIPO DE ERROR ESPEC√çFICO:`);
                logger.error(`‚ùå [${ttsDebugId}]   - Error code enum: ${cancellation.errorCode}`);
                logger.error(`‚ùå [${ttsDebugId}]   - Es AuthenticationFailure: ${cancellation.errorCode === sdk.CancellationErrorCode.AuthenticationFailure}`);
                logger.error(`‚ùå [${ttsDebugId}]   - Es ConnectionFailure: ${cancellation.errorCode === sdk.CancellationErrorCode.ConnectionFailure}`);
                logger.error(`‚ùå [${ttsDebugId}]   - Es ServiceTimeout: ${cancellation.errorCode === sdk.CancellationErrorCode.ServiceTimeout}`);
              }
              
              reject(new Error(`Azure TTS Cancelado [${cancellation.reason}/${cancellation.errorCode}]: ${cancellation.errorDetails}`));
            } else {
              logger.error(`‚ùå [${ttsDebugId}] RAZ√ìN DESCONOCIDA despu√©s de ${callbackDuration}ms:`);
              logger.error(`‚ùå [${ttsDebugId}]   - Reason: ${result.reason}`);
              logger.error(`‚ùå [${ttsDebugId}]   - Error details: ${result.errorDetails || 'Sin detalles'}`);
              logger.error(`‚ùå [${ttsDebugId}]   - Todas las razones disponibles: ${Object.keys(sdk.ResultReason)}`);
              
              reject(new Error(result.errorDetails || `Azure TTS raz√≥n desconocida: ${result.reason}`));
            }
            
            logger.info(`üîç [${ttsDebugId}] Cerrando synthesizer...`);
            synthesizer.close();
            logger.info(`üîç [${ttsDebugId}] ===== FIN CALLBACK =====`);
          },
          (error) => {
            const errorTime = Date.now();
            const errorDuration = errorTime - ttsStartTime;
            
            clearTimeout(timeout);
            logger.error(`‚ùå [${ttsDebugId}] ===== ERROR CALLBACK despu√©s de ${errorDuration}ms =====`);
            logger.error(`‚ùå [${ttsDebugId}] Error tipo: ${typeof error}`);
            logger.error(`‚ùå [${ttsDebugId}] Error string: ${error}`);
            logger.error(`‚ùå [${ttsDebugId}] Error objeto: ${JSON.stringify(error, null, 2)}`);
            
            if (error && typeof error === 'object') {
              logger.error(`‚ùå [${ttsDebugId}] Error properties: ${Object.keys(error)}`);
              if (error.message) logger.error(`‚ùå [${ttsDebugId}] Error message: ${error.message}`);
              if (error.code) logger.error(`‚ùå [${ttsDebugId}] Error code: ${error.code}`);
              if (error.stack) logger.error(`‚ùå [${ttsDebugId}] Error stack: ${error.stack}`);
            }
            
            synthesizer?.close();
            reject(new Error(`Azure TTS Error en callback: ${error}`));
          }
        );
        
        logger.info(`üîç [${ttsDebugId}] speakTextAsync llamado, esperando callback...`);
      });
    } catch (error) {
      const generateEndTime = Date.now();
      const generateDuration = generateEndTime - generateStartTime;
      
      logger.error(`‚ùå [${generateId}] ===== ERROR GENERAL despu√©s de ${generateDuration}ms =====`);
      logger.error(`‚ùå [${generateId}] Error tipo: ${typeof error}`);
      logger.error(`‚ùå [${generateId}] Error name: ${error.name}`);
      logger.error(`‚ùå [${generateId}] Error message: ${error.message}`);
      logger.error(`‚ùå [${generateId}] Error stack: ${error.stack}`);
      
      if (error.code) {
        logger.error(`‚ùå [${generateId}] Error code: ${error.code}`);
      }
      
      // An√°lisis espec√≠fico de errores comunes
      if (error.message.includes('authentication')) {
        logger.error(`‚ùå [${generateId}] PROBLEMA DE AUTENTICACI√ìN - Verificar AZURE_SPEECH_KEY`);
      } else if (error.message.includes('network') || error.message.includes('connection')) {
        logger.error(`‚ùå [${generateId}] PROBLEMA DE RED - Verificar conectividad`);
      } else if (error.message.includes('timeout')) {
        logger.error(`‚ùå [${generateId}] TIMEOUT - Azure TTS tard√≥ demasiado`);
      }
      
      return {
        success: false,
        error: error.message,
        errorCode: error.code,
        duration: generateDuration
      };
    }
  }

  // A√±adir naturalidad universal al texto (funciona para Lola y Dar√≠a)
  addUniversalNaturalness(text) {
    let naturalText = text;
    
    // üé≠ PAUSAS NATURALES UNIVERSALES
    naturalText = naturalText
      // Pausas despu√©s de saludos
      .replace(/^(hola|buenas|buenos d√≠as|buenas tardes)/gi, '$1<break time="300ms"/>')
      // Pausas antes de preguntas
      .replace(/(\?)/g, '<break time="200ms"/>$1')
      // Pausas despu√©s de comas (respiraci√≥n natural)
      .replace(/(,)/g, '$1<break time="150ms"/>')
      // Pausas en transiciones
      .replace(/\b(entonces|bueno|pues|vale)\b/gi, '<break time="200ms"/>$1<break time="150ms"/>');
    
    // üéµ VARIACIONES DE VELOCIDAD UNIVERSALES
    naturalText = naturalText
      // Nombre de empresa m√°s lento (√©nfasis)
      .replace(/\b([A-Z][a-z√°√©√≠√≥√∫√±]+\s+[A-Z][a-z√°√©√≠√≥√∫√±]+)\b/g, '<prosody rate="slow"><emphasis level="moderate">$1</emphasis></prosody>')
      // N√∫meros de tel√©fono m√°s lentos
      .replace(/\b(\d{3}[\s-]?\d{3}[\s-]?\d{3})\b/g, '<prosody rate="slow">$1</prosody>')
      // Palabras importantes con √©nfasis
      .replace(/\b(importante|urgente|necesario|ayuda)\b/gi, '<emphasis level="strong">$1</emphasis>');
    
    // üé™ MULETILLAS NATURALES UNIVERSALES (ocasionales)
    if (Math.random() < 0.3) { // 30% de probabilidad
      const muletillas = ['eee', 'mmm', 'pues'];
      const muletilla = muletillas[Math.floor(Math.random() * muletillas.length)];
      naturalText = `<break time="200ms"/>${muletilla}<break time="150ms"/> ${naturalText}`;
    }
    
    // üéØ ALARGAMIENTO OCASIONAL DE PALABRAS (universal)
    if (Math.random() < 0.2) { // 20% de probabilidad
      naturalText = naturalText
        .replace(/\bvale\b/gi, 'vaaale')
        .replace(/\bbueno\b/gi, 'bueeeno')
        .replace(/\bs√≠\b/gi, 's√≠√≠√≠');
    }
    
    // üîÑ PAUSAS DE CONSULTA UNIVERSALES
    naturalText = naturalText
      .replace(/\b(d√©jame ver|un momento|espera)\b/gi, '<break time="250ms"/>$1<break time="400ms"/>')
      .replace(/\b(consultando|revisando|mirando)\b/gi, '<break time="200ms"/>$1<break time="300ms"/>');
    
    return naturalText;
  }

  // Generar audio con SSML para configuraci√≥n avanzada de voz
  async generateSpeechWithSSML(text, voiceId = null, outputPath = null, voiceSettings = null) {
    try {
      const voice = this.getVoiceById(voiceId || this.defaultVoice);
      logger.info(`üéµ Generando audio Azure TTS con SSML - Voz: ${voice.name}`);
      
      // Configuraci√≥n por defecto si no se proporciona
      const settings = {
        rate: voiceSettings?.rate || 'medium',           // slow, medium, fast, +20%, -10%
        pitch: voiceSettings?.pitch || 'medium',         // low, medium, high, +2st, -50Hz
        volume: voiceSettings?.volume || 'medium',       // silent, x-soft, soft, medium, loud, x-loud
        style: voiceSettings?.style || 'friendly',       // cheerful, sad, angry, excited, friendly, etc.
        emphasis: voiceSettings?.emphasis || 'moderate'   // strong, moderate, reduced
      };
      
      logger.info(`üéµ Configuraci√≥n SSML: ${JSON.stringify(settings)}`);
      
      // A√±adir naturalidad universal al texto (funciona para Lola y Dar√≠a)
      const naturalText = this.addUniversalNaturalness(text);
      logger.info(`üé≠ Texto con naturalidad aplicada: ${naturalText.substring(0, 100)}...`);
      
      // Crear SSML con configuraci√≥n avanzada
      const ssml = `
        <speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" 
               xmlns:mstts="https://www.w3.org/2001/mstts" xml:lang="${voice.locale}">
          <voice name="${voice.name}">
            <mstts:express-as style="${settings.style}">
              <prosody rate="${settings.rate}" pitch="${settings.pitch}" volume="${settings.volume}">
                ${naturalText}
              </prosody>
            </mstts:express-as>
          </voice>
        </speak>
      `;
      
      logger.info(`üéµ SSML generado: ${ssml.substring(0, 200)}...`);
      
      // Configurar Azure Speech SDK
      const speechConfig = sdk.SpeechConfig.fromSubscription(
        process.env.AZURE_SPEECH_KEY,
        process.env.AZURE_SPEECH_REGION
      );
      
      let audioConfig;
      if (outputPath) {
        const outputDir = path.dirname(outputPath);
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }
        audioConfig = sdk.AudioConfig.fromAudioFileOutput(outputPath);
      } else {
        audioConfig = sdk.AudioConfig.fromDefaultSpeakerOutput();
      }
      
      const synthesizer = new sdk.SpeechSynthesizer(speechConfig, audioConfig);
      
      return new Promise((resolve, reject) => {
        // Timeout de 10 segundos para Azure TTS
        const timeout = setTimeout(() => {
          logger.error(`‚ùå TIMEOUT Azure TTS despu√©s de 10 segundos`);
          synthesizer.close();
          reject(new Error('Azure TTS timeout despu√©s de 10 segundos'));
        }, 10000);

        synthesizer.speakSsmlAsync(
          ssml,
          (result) => {
            clearTimeout(timeout);
            if (result.reason === sdk.ResultReason.SynthesizingAudioCompleted) {
              logger.info(`üéµ Audio Azure con SSML generado exitosamente`);
              
              if (outputPath && fs.existsSync(outputPath)) {
                const stats = fs.statSync(outputPath);
                logger.info(`üéµ Audio guardado: ${outputPath} (${stats.size} bytes)`);
              }
              
              resolve({
                success: true,
                outputPath,
                audioBuffer: result.audioData,
                voiceSettings: settings
              });
            } else {
              logger.error(`‚ùå Error en s√≠ntesis SSML: ${result.reason}`);
              logger.error(`‚ùå Detalles del error: ${result.errorDetails || 'No hay detalles'}`);
              logger.error(`‚ùå C√≥digo de resultado: ${result.reason} (${sdk.ResultReason[result.reason] || 'Desconocido'})`);
              logger.error(`‚ùå SSML problem√°tico: ${ssml.substring(0, 500)}`);
              reject(new Error(`Error en s√≠ntesis SSML: ${result.reason} - ${result.errorDetails || 'Sin detalles'}`));
            }
            synthesizer.close();
          },
          (error) => {
            clearTimeout(timeout);
            logger.error(`‚ùå Error SSML Azure TTS: ${error}`);
            synthesizer.close();
            reject(error);
          }
        );
      });
    } catch (error) {
      logger.error(`‚ùå Error generando audio SSML Azure TTS: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Generar audio para una respuesta del bot de llamadas
  async generateBotResponse(responseText, voiceId = null, voiceSettings = null) {
    try {
      logger.info(`üîç DEBUG Azure TTS - generateBotResponse iniciado con texto: "${responseText.substring(0, 50)}..."`);  
      logger.info(`üîç DEBUG Azure TTS - voz recibida: ${voiceId || this.defaultVoice}`);
      logger.info(`üîç DEBUG Azure TTS - configuraci√≥n de voz: ${JSON.stringify(voiceSettings)}`);
      
      // Crear nombre de archivo √∫nico
      const timestamp = Date.now();
      const fileName = `bot_response_azure_${timestamp}.mp3`;
      const outputDir = path.join(__dirname, '../../public/audio');
      const outputPath = path.join(outputDir, fileName);
      
      // Crear directorio si no existe
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      
      logger.info(`üîç DEBUG Azure TTS - Llamando a generateSpeech con outputPath: ${outputPath}`);
      
      // Generar el audio con configuraci√≥n de voz
      const result = await this.generateSpeechWithSSML(responseText, voiceId, outputPath, voiceSettings);
      
      logger.info(`üîç DEBUG Azure TTS - generateSpeech completado, result.success: ${result?.success}`);
      
      if (!result.success) {
        throw new Error(result.error);
      }
      
      // Calcular la URL p√∫blica
      const baseUrl = process.env.BASE_URL || 'https://saas-ai-automation.onrender.com';
      const publicUrl = `${baseUrl}/audio/${fileName}`;
      
      return {
        success: true,
        audioUrl: publicUrl,
        audioPath: outputPath,
        durationEstimate: this.estimateAudioDuration(responseText),
        voiceUsed: this.getVoiceById(voiceId || this.defaultVoice)
      };
    } catch (error) {
      logger.error(`‚ùå Error generando respuesta de bot Azure TTS: ${error.message}`);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Estimar duraci√≥n del audio (aproximado)
  estimateAudioDuration(text) {
    // Aproximadamente 150 palabras por minuto en espa√±ol
    const words = text.split(' ').length;
    const minutes = words / 150;
    return Math.ceil(minutes * 60); // Devolver en segundos
  }

  // Obtener lista de voces disponibles
  getAvailableVoices() {
    return this.availableVoices;
  }

  // Validar configuraci√≥n
  isConfigured() {
    return !!this.subscriptionKey;
  }
}

module.exports = new AzureTTSService();
